#!/bin/bash
#================
# FILE          : linuxrc
#----------------
# PROJECT       : OpenSuSE KIWI Image System
# COPYRIGHT     : (c) 2006 SUSE LINUX Products GmbH. All rights reserved
#               :
# AUTHOR        : Marcus Schaefer <ms@suse.de>
#               :
# BELONGS TO    : Operating System images
#               :
# DESCRIPTION   : This file is changed to become the real
#               : linuxrc script which is used to prepare the
#               : operating system for the main image
#               :
#               :
# STATUS        : BETA
#----------------
#======================================
# Exports (General)...
#--------------------------------------
export PATH="/sbin:/bin:/usr/sbin:/usr/bin"
export IFS_ORIG=$IFS
export DEBUG=0

#======================================
# Exports (Configuration)...
#--------------------------------------
export systemIntegrity=clean
export LIVECD_CONFIG="/cdrom/config.isoclient"
export LIVECD="/livecd"
export LOCAL_BOOT="no"

#======================================
# Exports kernel options
#--------------------------------------
export kernel_cmdline=($@)

#======================================
# Functions...
#--------------------------------------
. /include
initialize

#======================================
# Start logging
#--------------------------------------
errorLogStart

#======================================
# Update library path
#--------------------------------------
ldconfig

#======================================
# 1) Mounting local file systems
#--------------------------------------
mountSystemFilesystems &>/dev/null

#======================================
# 2) probe for livecd_config in cmdline
#--------------------------------------
includeKernelParameters
if grep -i -q "livecd_config=[a-zA-Z0-9/]" /proc/cmdline; then
    export LIVECD_CONFIG=`sed 's/.*livecd_config=\([^ ]*\).*/\1/' /proc/cmdline`
fi
if grep -i -q "toram" /proc/cmdline; then
    export TORAM="true"
fi

if [ ! -z "$kiwi_arch" ]; then
    export ARCH="$kiwi_arch"
else
    export ARCH=`arch`
fi

#======================================
# 3) Prepare module load support 
#--------------------------------------
touch /etc/modules.conf
touch /lib/modules/*/modules.dep

#======================================
# 4) run udevd
#--------------------------------------
udevStart

#======================================
# 5) start boot shell and logging
#--------------------------------------
startShell

#======================================
# 6) Including required kernel modules
#--------------------------------------
probeDevices

#======================================
# 7) Mount the live image device
#--------------------------------------
if searchImageISODevice;then
    if [ ! -z "$mediacheck" ]; then
        runMediaCheck
    fi
    if [ ! -z "$kiwi_hybrid" ];then
        setupHybridPersistent
    fi
    kiwiMount "$biosBootDevice" "/cdrom" "-o ro" 1>&2
fi

#======================================
# 8) Load configuration
#--------------------------------------
importFile < $LIVECD_CONFIG
if [ ! -z "$HYBRID_RW" ];then
    if [ ! -z "$UNIONFS_CONFIG" ];then
        tmp_rwDevice=$(echo $UNIONFS_CONFIG | cut -d , -f 1)
        UNIONFS_CONFIG=$(
            echo $UNIONFS_CONFIG | sed -e s@$tmp_rwDevice@$HYBRID_RW@
        )
    else
        IMAGE=$(echo $IMAGE | sed -e s@/dev/ram1@$HYBRID_RW@)
    fi
fi

#======================================
# 9) Download RW part of the CD image
#--------------------------------------
for i in $(echo $IMAGE | tr , ' ');do
    field=0
    for n in $(echo $i | tr ';' ' ');do
    case $field in
        0) imageDevice=$n ; field=1 ;;
        1) imageName=$n   ; field=2 ;;
        2) imageVersion=$n
    esac
    done
    imageReadOnly="$imageName"
    imageReadOnly=$(echo $imageReadOnly | sed -e "s@\.${ARCH}\$@@")
    imageReadOnly="$imageReadOnly-read-only.$ARCH-$imageVersion"
    imageName="/cdrom/$imageName-$imageVersion"
    gzippName=$imageName.gz
    imageMD5s="$imageName.md5"
    if [ ! -z "$UNIONFS_CONFIG" ] || [ ! -z "$COMBINED_IMAGE" ];then
        continue
    fi
    while true;do
        read sum1 blocks blocksize zblocks zblocksize < $imageMD5s
        if ! validateSize;then
            systemException \
                "Not enough RAM available for this image" \
            "reboot"
        fi
        needBytes=$(gzip -l $gzippName|tail -n1|sed -e "s@ \+@:@g"|cut -f3 -d:)
        needMByte=$((needBytes / 1024 / 1024))
        if [ -x /usr/bin/dcounter ];then
            errorLogStop
            Echo -n "Loading $imageName [$imageDevice] "
            gzip -cd $gzippName |\
                dcounter -s $needMByte | dd of=$imageDevice &>/dev/null
            errorLogContinue
            echo
        else
            Echo "Loading $imageName [$imageDevice]..."
            gzip -cd $gzippName | dd of=$imageDevice
        fi
        dd if=$imageDevice bs=1024 |\
            head --bytes=$((blocks * blocksize)) |\
            md5sum - > /etc/ireal.md5
        read sum2 dumy < /etc/ireal.md5
        if test $sum1 = $sum2;then
            Echo "Image checksum test: fine :-)"
            break
        fi
        Echo "Image checksum test failed:"
        echo
        Echo -b "1) Data corruption while loading the image:"
        Echo -b "   will give it a new try..."
        echo
        Echo -b "2) ramdisk size is too small for the image:"
        Echo -b "   try to set the kernel parameter ramdisk_size=<size>"
        echo
        Echo "Retry to load image..."
        sleep 15
    done
    rm -f /etc/ireal.md5
done
CDUmount

#======================================
# 10) Get filesystem type
#--------------------------------------
if [ -z "$UNIONFS_CONFIG" ] && [ -e "$imageDevice" ];then
    probeFileSystem $imageDevice
    if [ "$FSTYPE" = "luks" ];then
        luksOpen $imageDevice
        imageDevice=$luksDeviceOpened
        probeFileSystem $imageDevice
        export haveLuks=yes
    fi
    resizeFilesystem $imageDevice
fi

#======================================
# 11) Check for swap space
#--------------------------------------
swapSpace=$(searchSwapSpace)
if [ ! -z "$swapSpace" ];then
    Echo "Found swap space on: $swapSpace"
fi

#======================================
# 12) Mount OS image to /mnt
#--------------------------------------
runHook premount
if [ -z "$UNIONFS_CONFIG" ] && [ -z "$COMBINED_IMAGE" ];then
    #======================================
    # 12.1) mount RW part and CD to /mnt
    #--------------------------------------
    if ! mount $imageDevice /mnt >/dev/null;then
        systemException "Failed to mount RW root filesystem" "reboot"
    fi
    cdopt=$(CDMountOption $biosBootDevice)
    mountOrCopyLiveCD
    #======================================
    # 12.2) Create RO Link list
    #--------------------------------------
    cd /mnt
    if [ ! -d $LIVECD/read-only-system ];then
        Echo "Mounting compressed read only tree..."
        rosys="/read-only"
        rosrc="$LIVECD/$imageReadOnly"
        mkdir -p $rosys
        if ! kiwiMount $rosrc $rosys "-o loop";then
            systemException "Failed to mount RO root filesystem" "reboot"
        fi
        Echo "Creating live media links..."
        for dir in bin boot lib lib64 opt sbin usr;do
            ln -s read-only/$dir $dir
        done
    else
        Echo "Creating live media links..."
        for dir in bin boot lib lib64 opt sbin usr;do
            if [ -d $LIVECD/read-only-system/$dir ];then
                ln -s $LIVECD/read-only-system/$dir $dir
            fi
        done
    fi
    cd /
else
    #======================================
    # 12.1) mount CD to /mnt and unify
    #--------------------------------------
    if [ ! -z "$COMBINED_IMAGE" ]; then
        Echo "Mounting compressed split tree..."
        imageReadOnly=$(echo $imageReadOnly | sed -e "s/-read-only//")
    else
        Echo "Mounting compressed unified tree..."
    fi
    cdopt=$(CDMountOption $biosBootDevice)
    mountOrCopyLiveCD
    if ! mountSystem /dev/loop1 $LIVECD/$imageReadOnly;then
        systemException "Failed to mount root filesystem" "reboot"
    fi
fi
validateRootTree
runHook postmount

#======================================
# 13) Create system dependant files
#--------------------------------------
setupDefaultFstab /config
updateRootDeviceFstab /config $imageDevice
if [ ! -z "$swapSpace" ];then
    updateSwapDeviceFstab /config $swapSpace
fi

#======================================
# 14) copy system dependant files
#--------------------------------------
setupConfigFiles

#======================================
# 15) update system dependant files
#--------------------------------------
setupInittab /mnt

#======================================
# keytable
#--------------------------------------
if [ ! -z "$keytable" ] && [ ! $HYBRID_RW_EXIST ];then
keymap=$keytable.map.gz
baseUpdateSysConfig /mnt/etc/sysconfig/keyboard KEYTABLE $keymap
    key=$(echo $keytable | cut -c 1-2)
    echo -e "\nLayoutList=us,$key" >> /mnt/etc/kde4/share/config/kxkbrc
    echo -e "Use=true" >> /mnt/etc/kde4/share/config/kxkbrc
    case $key in
        "de") TIMEZONE_NAME="Europe/Berlin";;
        "fr") TIMEZONE_NAME="Europe/Paris";;
        "es") TIMEZONE_NAME="Europe/Madrid";;
        "ru") TIMEZONE_NAME="Europe/Moscow";;
    esac
fi
#======================================
# locale
#--------------------------------------
if [ ! -z "$lang" ] && [ ! $HYBRID_RW_EXIST ];then
    language=$lang.UTF-8
    baseUpdateSysConfig /mnt/etc/sysconfig/language RC_LANG $language
fi

if [ ! $HYBRID_RW_EXIST ]; then
    BOOTDISK_KEY="$LIVECD/bootdisk.key"
    BOOTDISK_CONF_DIR='/mnt/etc/lsoft'
    IP_DIR="/mnt/etc/NetworkManager/system-connections"
    IP_FILE="$BOOTDISK_CONF_DIR/default"

    # parse bootdisk.key
    _username=$(head -n1 $BOOTDISK_KEY | sed 's/\~//g')
    _key=$(head -n2 $BOOTDISK_KEY | tail -n1 | sed 's/\^//g')
    _params=$(head -n3 $BOOTDISK_KEY | tail -n1 | sed 's/\+//g')
    _cmd_opts=$(tail -n1 $BOOTDISK_KEY | sed 's/\#//g')
    _tzIANA=

    if [[ $_cmd_opts == !!!TZ=* ]]; then
        _tzIANA=$(echo $_cmd_opts | cut -f 4 -d '!' | sed 's/TZ=//')
        _cmd_opts=$(echo $_cmd_opts | sed 's/^!!!TZ=[^!]*!!!//')
    fi

    if [ ! -z "$_username" ] && [ ! -z "$_key" ]; then #key
        mkdir -p "$BOOTDISK_CONF_DIR"
        echo "name=$_username" > "$BOOTDISK_CONF_DIR/bootdisk.conf"
        echo "key=$_key" >> "$BOOTDISK_CONF_DIR/bootdisk.conf"
    fi

    if [ ! -z $_params ]; then
        OIFS=$IFS
        IFS='|'
        params_arr=($_params)
        IFS=$OIFS
        if [ ! -z ${params_arr[0]} ]; then #timezone
            case ${params_arr[0]} in
                "-1") TIMEZONE_NAME="$_tzIANA";;
                "0") TIMEZONE_NAME="Asia/Kamchatka";;
                "1") TIMEZONE_NAME="Asia/Sakhalin";;
                "2") TIMEZONE_NAME="Australia/Melbourne";;
                "3") TIMEZONE_NAME="Asia/Tokyo";;
                "4") TIMEZONE_NAME="Asia/Hong_Kong";;
                "5") TIMEZONE_NAME="Asia/Bangkok";;
                "6") TIMEZONE_NAME="Asia/Almaty";;
                "7") TIMEZONE_NAME="Asia/Tashkent";;
                "8") TIMEZONE_NAME="Asia/Muscat";;
                "9") TIMEZONE_NAME="Europe/Moscow";;
                "10") TIMEZONE_NAME="Europe/Helsinki";;
                "11") TIMEZONE_NAME="Europe/Berlin";;
                "12") TIMEZONE_NAME="GMT";;
                "13") TIMEZONE_NAME="Atlantic/Azores";;
                "14") TIMEZONE_NAME="America/Noronha";;
                "15") TIMEZONE_NAME="Brazil/East";;
                "16") TIMEZONE_NAME="Canada/Atlantic";;
                "17") TIMEZONE_NAME="US/Eastern";;
                "18") TIMEZONE_NAME="US/Central";;
                "19") TIMEZONE_NAME="US/Mountain";;
                "20") TIMEZONE_NAME="US/Pacific";;
                "21") TIMEZONE_NAME="US/Alaska";;
                "22") TIMEZONE_NAME="US/Hawaii";;
                "23") TIMEZONE_NAME="US/Samoa";;
                "24") TIMEZONE_NAME="Etc/GMT+12";;
            esac
        fi

        if [ ${params_arr[3]} == '0' ]; then #disable network
            mount -t proc none /mnt/proc
            mount -o bind /dev /mnt/dev
            chroot /mnt systemctl disable NetworkManager.service
            umount /mnt/proc
            umount /mnt/dev
        else
            if [ ${params_arr[4]} == '0' ]; then #disable firewall
                mount -t proc none /mnt/proc
                mount -o bind /dev /mnt/dev
                chroot /mnt systemctl disable SuSEfirewall2.service
                chroot /mnt systemctl disable SuSEfirewall2_init.service
                umount /mnt/proc
                umount /mnt/dev
                baseUpdateSysConfig /mnt/etc/sysconfig/network/config FIREWALL NO
            fi

            if [ ${params_arr[5]} == '0' ]; then #static ip
                if [ -z ${params_arr[6]} ] || [ -z ${params_arr[7]} ] || [ -z ${params_arr[8]} ] || [ -z ${params_arr[9]} ]; then #
                    echo "Error: wrong static ip settings. Fall back to dhcp."
                else
                    nbits=0
                    OIFS=$IFS
                    IFS=.
                    for dec in ${params_arr[7]}; do
                        case $dec in
                            255) let nbits+=8;;
                            254) let nbits+=7 ; break ;;
                            252) let nbits+=6 ; break ;;
                            248) let nbits+=5 ; break ;;
                            240) let nbits+=4 ; break ;;
                            224) let nbits+=3 ; break ;;
                            192) let nbits+=2 ; break ;;
                            128) let nbits+=1 ; break ;;
                            0);;
                        esac
                    done
                    IFS=$OIFS

                    sed "s/@@ADDRESS@@/${params_arr[6]}/" -i $IP_FILE
                    sed "s/@@MASK@@/$nbits/" -i $IP_FILE
                    sed "s/@@DNS@@/${params_arr[8]}/" -i $IP_FILE
                    sed "s/@@GATEWAY@@/${params_arr[9]}/" -i $IP_FILE

                    mkdir -p "$IP_DIR"
                    cp -pf "$IP_FILE" "$IP_DIR/"
                fi
            fi
        fi

        if [ ! -z "${params_arr[10]}" ]; then #constants
            AUTOSTART_FILE="$BOOTDISK_CONF_DIR/${params_arr[10]}.desktop"
            if [ -e "$AUTOSTART_FILE" ]; then
                if [ ${params_arr[1]} == '1' ]; then #autostart
                    sed "s/@@OPTIONS@@/$_cmd_opts/" -i $AUTOSTART_FILE
                fi
                cp -f "$AUTOSTART_FILE" /mnt/usr/share/autostart
            fi
        fi
    fi
fi

if [ ! -z "$TIMEZONE_NAME" ];then
    if [ -f /mnt/usr/share/zoneinfo/$TIMEZONE_NAME ];then
        ln -sf /usr/share/zoneinfo/$TIMEZONE_NAME /mnt/etc/localtime
        baseUpdateSysConfig /mnt/etc/sysconfig/clock TIMEZONE $TIMEZONE_NAME
    else
        Echo "timezone: $TIMEZONE_NAME not found"
    fi
fi

#======================================
# Add repos (for offline build support)
#--------------------------------------
mount -t proc none /mnt/proc
mount -o bind /dev /mnt/dev

baseRepo="http://download.opensuse.org/distribution/13.2/repo/oss"
baseName="suse-13.2"
chroot /mnt zypper ar $baseRepo $baseName

baseRepo="http://download.opensuse.org/distribution/13.2/repo/non-oss"
baseName="suse-13.2-non-oss"
chroot /mnt zypper ar $baseRepo $baseName

chroot /mnt zypper mr -a -r --no-gpgcheck

umount /mnt/proc
umount /mnt/dev

#======================================
# 16) setup real root device
#--------------------------------------
echo 256 > /proc/sys/kernel/real-root-dev

#======================================
# 17) umount system filesystems
#--------------------------------------
umountSystemFilesystems

#======================================
# 18) copy initrd files to image
#--------------------------------------
importBranding
cp /preinit /mnt
cp /include /mnt

#======================================
# 19) kill boot shell
#--------------------------------------
killShell

#======================================
# 20) Activate new root
#--------------------------------------
activateImage

#======================================
# 21) Unmount initrd / system init
#--------------------------------------
bootImage
